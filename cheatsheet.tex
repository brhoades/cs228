\documentclass[fontsize=5pt]{scrartcl}

%
% Original Page by LinuxMercedes
%

\usepackage[
        nohead,
        nofoot,
        left=0.55in,
        right=0.55in,
        top=0.55in,
        bottom=0.55in,
]{geometry}

\usepackage{amsmath}

\usepackage{multicol}
\setlength{\columnsep}{5pt}

\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\pagenumbering{gobble}

\usepackage{enumitem}
\setlist[itemize]{itemsep=-2pt, itemindent=0pt, leftmargin=*}
\setlist[enumerate]{itemsep=-2pt, itemindent=0pt, leftmargin=*}

\usepackage[compact]{titlesec}
\titlespacing{\section}{-1pt}{-1pt}{-1pt}
\titlespacing{\subsection}{-1pt}{-1pt}{-1pt}

\usepackage{listings}

%was 3 3 3 3
\DeclareMathSizes{4pt}{4pt}{3pt}{3pt}

\begin{document}

\begin{multicols}{3}
  \section{Definitions}
    \begin{itemize}
      \item \textbf{Analytical Solution}: using a formula to give an exact answer.
      \item \textbf{Numerical Solution}: obtaining an approximation for the answer, 
            ie with a Taylor Series, to get a equation which can be solved with available
            information.
    \end{itemize}

  \section{Formulas}
      \begin{itemize}
        \item \textbf{True Error}: $E_t =$ True value - Approximation ($\pm$)
        \item \textbf{True \% Rel. Error}: $\epsilon_t = (\frac{\text{True value} - \text{Approximation}}{\text{True Value}})\cdot100\%$
        \item \textbf{Aprox. Rel. Error}: $\epsilon_a =  |\frac{\text{This Approx.} - \text{Last Approx}}{\text{This Approx.}}|\cdot100\%$
      \end{itemize}
      
  \section{Algorithms}
    \subsection{General Iterative}
      Computations can be repeated until criterion is satisfied $|\epsilon_a| < \epsilon_s$. \\
      If $n$ sig figs are requested: $\epsilon_s = \frac{10^{2-n}}{2}\%$ \\
    \subsection{Roots of One Equation}
      \begin{itemize}
       \item \textbf{Graphical Approach}: Looking at a graph to approximate where the equation is hitting the x axis. Give 
          something like ``two distinct roots between x=4.3 and x=4.2.''
       \item \textbf{Bisection Method}: Cut a graph into two repeatedly, then look for changes in sign.
        \begin{itemize}
          \item Iterations required: $k \geq \lceil log_2|\frac{L_0}{x_r \cdot \epsilon_{tol}}|\rceil$
          \item Steps:
          \begin{enumerate}
              \item Choose lower $x_l$ and upper $x_u$ guesses for the root so that the function changes sign over the
              interval. This can be checked by ensuring that $f(x_l)f(x_r) < 0$.
              \item Guess at the root, $x_r$, with $x_r = \frac{x_l + x_u}{2}$
              \item Take the following substeps, then return to step 2
              \begin{enumerate}
                \item $f(x_l)f(x_r) < 0$, $x_u = x_r$
                \item $f(x_l)f(x_r) > 0$, $x_l = x_r$
                \item $f(x_l)f(x_r) = 0$, root is $x_r$
              \end{enumerate}
          \end{enumerate}
          \item This method is easy, always finds a root, and number of iterations required can be computed.
          \item However, this method is slow, needs good initial guesses, and doesn't account for if $f(x_l)$
            is closer to 0, it is likely that the root is closer to $x_l$.
        \end{itemize}
        \item \textbf{False-Position Method}: A solution can be approximated for any given $f(x)$ between $x_u$
          and $x_l$ via linear interpolation. Looking for an $x_r \ni l(x_r) = 0$, $l(x)$ is the linear
          approx. between for the bounds above.
          $x_r = \frac{x_lf_u-x_uf_l}{f_u-f_l}$
        \item \textbf{Simple Fixed-point}: With the function arranged with x on the LHS, ie $x = 1+\frac{2}{x}$ or
          $x = \sqrt{x+2}$ where now $g(x) = x$, $x_k = g(x_{k-1})$ and $x_0$ is given. Iterate through solving
          for those points until the x value is the nearest to zero.
        \item \textbf{Newton-Raphson}: Most widely used formula for locating roots. Is equivalent to creating a 
        function that is tangent to the point given.
          \begin{itemize}
            \item $x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}$
            \item Most convenient when the derivative can be evaluated analytically
            \item Rate of convergence is quadratic/proportional to the square of the previous $E_{i+1} = O(E_{i^2})$
            \item Will not always converge, there is no convergence criterion, and it may converge very slowly.
          \end{itemize}
        \item \textbf{Secant Method}: Used often when the derivative cannot be determined analytically, and needs
          to be done numerically. Same as Newton-Raphson but with an expanded derivative, and carries the same
          properties.
          \begin{itemize}
            \item $x_{i+1} = x_i - f(x_i)\frac{x_i-x_{i-1}}{f(x_i)-f(x_{i-1})}$
            \item Requires two initial estimates of $x_0 x_1$, but is NOT bracketing.
          \end{itemize}
        \item \textbf{Modified Secant Method}: Uses a small perturbation fraction $\delta$ instead of a derivative. \\
          $x_{i+1} = x_i - f(x_i)\frac{\delta x_i}{f(x_i+\delta x_i-f(x_i)}$
      \end{itemize}
      
  \section{Reference}
    \subsection{Matlab}
      \begin{itemize}
        \item \textbf{Common Functions}:
          sqrt, 
          exp, 
          abs,  
          log, 
          log10, 
          factorial, 
          sin, 
          sind, 
          cos,  
          cosd, 
          tan, 
          tand, 
          cot, 
          cotd, 
          round, 
          fix, 
          floor, 
          rem(x,y)\textit{mod}
          ceil, 
          sprintf
        \item \textbf{Matrices} are defined in many ways, here are the most common:
          \lstset{language=Matlab}
          \begin{lstlisting}
a = [ 1 2 3 4 5 ]
b = [ 1 2; 3 4; 5 6 ]
c = [ 1 2
      3 4
      5 6 ]
          \end{lstlisting}%
          $%
          a = \left( 1 2 3 4 5 \right)\hspace{1mm}
          b = \left( \begin{array}{cc}
                      1 & 2 \\
                      3 & 4 \\ 
                      5 & 6 \\
                    \end{array}
                    \right)
          c = b
          $
        \end{itemize}
    \subsection{Matlab Examples}
      \begin{itemize}
        \item Bisection function in Matlab. Passes f(x), lower x, upper x, and a error / upper i.
        \lstset{language=Matlab}
        \begin{lstlisting}
% A sample call:
%bisection2(@func1, -2, 4, 0.001, 500)
function root = bisection(fx, xl, xu, es, imax);

if fx(xl)*fx(xu) > 0 % if guesses do not bracket
    disp('no bracket')
    return
end

for i=1:1:imax
   xr=(xu+xl)/2
   ea = abs((xu-xl)/xl);
   test= fx(xl)*fx(xr);
   if test < 0
       xu=xr;
   end
   if test > 0 xl=xr; end
   if test == 0 ea=0; end
   if ea < es break; end
end
%root = xr, it# = i, fx is original function
        \end{lstlisting}
        \item Newton's Method example code
          \lstset{language=Matlab}
          \begin{lstlisting}
function root = newtraph(func,dfunc,xr,es,maxit)
% Newton-Raphson method to find the root of a function
% call syntax:   newtraph(@func,@dfunc,xguess,es,maxit)
% 'func'(function), and 'dfunc'(its derivative) are defined 
% in files func.m and dfunc.m in the same directory
% inputs:
%   func = name of function 
%   dfunc = name of derivative of function 
%   xr = initial guess
%   es = stopping criterion (%)
%   maxit = (optional) maximum allowable iterations
% output:
%   root = real root

iter = 0;
while (1)
  xrold = xr;
  xr = xr - func(xr)/dfunc(xr);
  iter = iter + 1;
  if xr ~= 0, ea = abs((xr - xrold)/xr) * 100; end
  if ea <= es | iter >= maxit, break, end
end
fprintf('\n  Root= %f    #Iterations = %d \n', xr,iter);
fprintf(' How close is f(root) to zero?  f(root)= %f  \n', func(xr));
          \end{lstlisting}
        \end{itemize}
    \subsection{Math}
      \begin{itemize}
      \item \textbf{Taylor Series}: Provides a means to predict the value of a function at one point in terms of
             the function value and its derivatives at another. The function must be infinitely differentiable
             at f(a). An infinite number of terms yields an exact result for $x=a$.
        $f(x), x=a$: $\sum_{n=0} ^ {\infty} \frac {f^{(n)}(a)}{n!} \, (x-a)^{n}$
      \item \textbf{Matrix Multiplication}: Matrix multiplication is done by going right on the left matrix while going
        down on the right. After a row on the left is done, move to the next and repeat with the next column. Matrices'
        sizes are denoted by c x r, and for two matrices to multiply together, $r_1 = c_2$. Examples:
        \begin{itemize} %thanks wikipedia
          \item $\mathbf{A} = \begin{pmatrix} 
                a & b
                \end{pmatrix}\,, \quad \mathbf{B} = \begin{pmatrix} 
                x \\
                y 
                \end{pmatrix}\,,
                $
                $
                  \begin{pmatrix} 
                  a & b 
                  \end{pmatrix} \begin{pmatrix} 
                  x \\
                  y \\
                  \end{pmatrix} = ax + by \,,
                $ \\
                $
                  \begin{pmatrix} 
                  x \\
                  y \\
                  \end{pmatrix}\begin{pmatrix} 
                  a & b
                  \end{pmatrix} = \begin{pmatrix} 
                  xa & xb \\
                  ya & yb 
                  \end{pmatrix} \,.
                $

        \end{itemize}
      \end{itemize}
  \end{multicols}
\end{document}

