\documentclass[fontsize=5pt]{scrartcl}

%
% Original Page by LinuxMercedes
%

\usepackage[
        nohead,
        nofoot,
        left=0.55in,
        right=0.55in,
        top=0.55in,
        bottom=0.55in,
]{geometry}

\usepackage{amsmath,scalefnt}

\renewcommand*{\arraystretch}{.5}

\usepackage{multicol}
\setlength{\columnsep}{5pt}

\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\pagenumbering{gobble}

\usepackage{enumitem}
\setlist[itemize]{itemsep=-2pt, itemindent=0pt, leftmargin=*}
\setlist[enumerate]{itemsep=-2pt, itemindent=0pt, leftmargin=*}

\usepackage[compact]{titlesec}
\titlespacing{\section}{-1pt}{-1pt}{-1pt}
\titlespacing{\subsection}{-1pt}{-1pt}{-1pt}

\usepackage{listings}

%Y hoy yo reza que no empleo ni alma pobre encontrarÃ¡ esta magica negra.
%This is a custom 'tight' matrix for this cheatsheet. It's ugly.
\newenvironment{tmatrix}%
{ 
  \scalefont{.5}
  \setlength{\tabcolsep}{5pt}
  $\left[\hspace{-3.5pt}\begin{array}{c@{\hspace{1pt}}@{\hspace{1pt}}c@{\hspace{1pt}}c@{\hspace{1pt}}|@\hspace{0pt}c}
}%
{
   \end{array}\hspace{-3.5pt}\right]$
}

\newenvironment{tmatrix3}%
{ 
  %\scalefont{.5}
  %\setlength{\tabcolsep}{5pt}
  $\left[\hspace{-3.5pt}\begin{array}{c@{\hspace{1pt}}@{\hspace{1pt}}c@{\hspace{1pt}}c@{\hspace{3pt}}}
}%
{
   \end{array}\hspace{-3.5pt}\right]$
}

\newenvironment{tmatrix1}%
{ 
  %\scalefont{.5}
  %\setlength{\tabcolsep}{5pt}
  $\left[\hspace{-3.5pt}\begin{array}{c@{\hspace{3pt}}}
}%
{
   \end{array}\hspace{-3.5pt}\right]$
}


%was 3 3 3 3
\DeclareMathSizes{3pt}{3pt}{3pt}{3pt}

\begin{document}

\begin{multicols}{3}
  \section{Definitions}
    \begin{itemize}
      \item \textbf{Analytical Solution}: using a formula to give an exact answer.
      \item \textbf{Numerical Solution}: obtaining an approximation for the answer, 
            ie with a Taylor Series, to get a equation which can be solved with available
            information.
    \end{itemize}

  \section{Problems}
    \begin{enumerate}
      \item \textbf{Gaussian Elimination with Partial Pivoting  \underline{30pts}}
        \begin{itemize}
          \item \textbf{Gauss Elimination}: consists of two phases: forward elimination, back substitution. 
            Utilizes a matrix to do this.
            \item \textbf{Forward elimination}: reduces a matrix like so, \textbf{in this order}: \\
              \begin{tmatrix}
                1 & 3 & 1 & 9 \\
                \mathbf{1} & 1 & -1 & 1 \\
                3 & 11 & 5 & 35 \\
              \end{tmatrix} \hspace{-2pt}$\Rightarrow$\hspace{-4pt}%
              \begin{tmatrix}
              1 & 3 & 1 & 9 \\
              0 & -2 & -2 & -8 \\
              \mathbf{0} & 2 & 2 & 8
              \end{tmatrix} \hspace{-2pt}$\Rightarrow$\hspace{-4pt}%
              \begin{tmatrix}
              1 & 3 & 1 & 9 \\
              0 & -2 & -2 & -8 \\
              0 & \mathbf{0} & 0 & 0
              \end{tmatrix}\\
            \vspace{-2pt}\\
            It does this using multiples of other rows, added on to the row you are modifying. 
            The diagonal does not matter in this method, and can be any value. The objective is to make
            the bottom triangle zeros, which turns this into the U portion of the A=L\textbf{U}.\\
          \vspace{-6pt}
        \item \textbf{Back substitution}: takes the lowest segment of the matrix, here $0x+0y+0z=0$,
          solves, and plugs it into the next up portion. Here, $0x-2y-2z=-8$, and then further up again.
        \item \textbf{Pivoting}: Pivoting eases the problem by having the largest leading number pivoted
          to the top of the matrix, meaning no fractions of $\frac{1}{832}$ need to be multiplied from another row,
          as the first row is not modified. In the example above, the row would be swapped with the top. 
          Note that only one, whole row can be swapped with one other.
          Pivoting cannot happen in LU decomposition as it breaks the relation in the matrix. 
      \end{itemize}
          
      \item \textbf{LU Decomposition \underline{28pts}}: LU Decomposition mirrors the actions on the the main matrix
          to another, L, which can then be multiplied by U to get A. To summarize the process: Let $A=LU$ where A is the original matrix and substitute into $AX=B$. 
              This yields $LUX=B$... So solve for $X$ to get the answer
             and you get $UX= $ for your first equation, followed by $LY=B$ and $UX=Y$. Here is an example form of an equation translated to $AX=B$: \\
               $x_1+x_2-x_3=4 \\
               x_1-2x_2+3x_3=-6 \\
               2x_1+3x_2+x_3=7 \\$
              \begin{tmatrix3}
                1 & 1  & -1 \\
                1 & -2 & 3  \\
                2 & 3  & 1 
              \end{tmatrix3} %
              \begin{tmatrix1}
                $x_1 \\
                x_2 \\
                x_3$ \\
              \end{tmatrix1} $=$%
              \begin{tmatrix1}
                $4 \\
                 -6 \\
                 7 \\$
              \end{tmatrix1}

          \begin{enumerate}
            \item Perform Gaussian Elimination up to the point where you begin back substitution. Take this resultant matrix,
            $U$ (for upper). While performing the Gaussian elimination use the shortcut method for determining L. Start with a partial
            L: \\
            $L = $
            \begin{tmatrix3}
             $ 1 & 0 & 0$ \\
             $ ? & 1 & 1$ \\ 
             $ ? & ? & 1$ \\
            \end{tmatrix3}

            \item While transforming 
          

            
          \end{enumerate}

    \end{itemize}
    
  \section{Formulas}
      \begin{itemize}
        \item \textbf{True Error}: $E_t =$ True value - Approximation ($\pm$)
        \item \textbf{True \% Rel. Error}: $\epsilon_t = (\frac{\text{True value} - \text{Approximation}}{\text{True Value}})\cdot100\%$
        \item \textbf{Aprox. Rel. Error}: $\epsilon_a =  |\frac{\text{This Approx.} - \text{Last Approx}}{\text{This Approx.}}|\cdot100\%$
      \end{itemize}
      
  \section{Algorithms}
    
      
  \section{Reference}
    \subsection{Matlab}
      \begin{itemize}
        \item \textbf{Common Functions}:
          sqrt, 
          exp, 
          abs,  
          log, 
          log10, 
          factorial, 
          sin, 
          sind, 
          cos,  
          cosd, 
          tan, 
          tand, 
          cot, 
          cotd, 
          round, 
          fix, 
          floor, 
          rem(x,y)\textit{mod}
          ceil, 
          sprintf
        \item \textbf{Matrices} are defined in many ways, here are the most common:
          \lstset{language=Matlab}
          \begin{lstlisting}
a = [ 1 2 3 4 5 ]
b = [ 1 2; 3 4; 5 6 ]
c = [ 1 2
      3 4
      5 6 ]
          \end{lstlisting}%
          $%
          a = \left( 1 2 3 4 5 \right)\hspace{1mm}
          b = \left( \begin{array}{cc}
                      1 & 2 \\
                      3 & 4 \\ 
                      5 & 6 \\
                    \end{array}
                    \right)
          c = b
          $
        \end{itemize}
    \subsection{Matlab Examples}
      \begin{itemize}
        \item Bisection function in Matlab. Passes f(x), lower x, upper x, and a error / upper i.
          \lstset{language=Matlab,basicstyle=\footnotesize,breaklines=true}
        \begin{lstlisting}
% A sample call:
%bisection2(@func1, -2, 4,
% 0.001, 500)
function root = bisection(fx, xl,
  xu, es, imax);

if fx(xl)*fx(xu) > 0 % if 
% guesses do not bracket
    disp('no bracket')
    return
end

for i=1:1:imax
   xr=(xu+xl)/2
   ea = abs((xu-xl)/xl);
   test= fx(xl)*fx(xr);
   if test < 0
       xu=xr;
   end
   if test > 0 xl=xr; end
   if test == 0 ea=0; end
   if ea < es break; end
end
%root = xr, it# = i, fx is original function
        \end{lstlisting}
        \item Newton's Method example code
          \lstset{language=Matlab,basicstyle=\footnotesize,breaklines=true}
          \begin{lstlisting}
function root = newtraph(func,dfunc,xr,es,maxit)
% Newton-Raphson method to find the root of a function
% call syntax:   newtraph(@func,@dfunc,xguess,es,maxit)
% 'func'(function), and 'dfunc'(its derivative) are defined 
% in files func.m and dfunc.m in the same directory
% inputs:
%   func = name of function 
%   dfunc = name of derivative of function 
%   xr = initial guess
%   es = stopping criterion (%)
%   maxit = (optional) maximum allowable iterations
% output:
%   root = real root

iter = 0;
while (1)
  xrold = xr;
  xr = xr - func(xr)/dfunc(xr);
  iter = iter + 1;
  if xr ~= 0, ea = abs((xr - xrold)/xr) * 100; end
  if ea <= es | iter >= maxit, break, end
end
fprintf('\n  Root= %f    #Iterations = %d \n', xr,iter);
fprintf(' How close is f(root) to zero?  f(root)= %f  \n', func(xr));
          \end{lstlisting}
        \end{itemize}
    \subsection{Math}
      \begin{itemize}
      \item \textbf{Taylor Series}: Provides a means to predict the value of a function at one point in terms of
             the function value and its derivatives at another. The function must be infinitely differentiable
             at f(a). An infinite number of terms yields an exact result for $x=a$.
        \begin{itemize}
          \item $f(x), x=a$: $\sum_{n=0} ^ {\infty} \frac {f^{(n)}(a)}{n!} \, (x-a)^{n} + R_n$
          \item Remainder, h is step size and $\epsilon$ is the value which makes the final
          equation exact for the nth derivative: \\ $R_n = \frac{f^{n+1}(\epsilon)}{(n+1)!} (x_{i+1}-x_i)^{n+1}h_{n+1}$ \\
          
        \end{itemize}
      \item \textbf{Matrix Multiplication}: Matrix multiplication is done by going right on the left matrix while going
        down on the right. After a row on the left is done, move to the next and repeat with the next column. Matrices'
        sizes are denoted by c x r, and for two matrices to multiply together, $r_1 = c_2$. Examples:
        \begin{itemize} %thanks wikipedia
          \item $\mathbf{A} = \begin{pmatrix} 
                a & b
                \end{pmatrix}\,, \quad \mathbf{B} = \begin{pmatrix} 
                x \\
                y 
                \end{pmatrix}\,,
                $
                $
                  \begin{pmatrix} 
                  a & b 
                  \end{pmatrix} \begin{pmatrix} 
                  x \\
                  y \\
                  \end{pmatrix} = ax + by \,,
                $ \\
                $
                  \begin{pmatrix} 
                  x \\
                  y \\
                  \end{pmatrix}\begin{pmatrix} 
                  a & b
                  \end{pmatrix} = \begin{pmatrix} 
                  xa & xb \\
                  ya & yb 
                  \end{pmatrix} \,.
                $

        \end{itemize}
      \end{itemize}
  \end{multicols}
\end{document}

